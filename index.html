<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Pete Console</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    #log.chat-log {
      white-space: pre-wrap;
      overflow-y: auto;
    }
    #log.chat-log li.user {
      align-self: flex-end;
      background-color: #bfdbfe;
      padding: 0.25rem 0.5rem;
      border-radius: 0.375rem;
    }
    #log.chat-log li.system {
      align-self: flex-start;
      background-color: #e5e7eb;
      padding: 0.25rem 0.5rem;
      border-radius: 0.375rem;
    }
    #thoughts li {
      align-self: flex-start;
      color: #6b7280;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
</head>
<body class="min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-50 to-slate-100 font-sans text-gray-800">
  <div x-data="chatApp()" x-init="init()" class="flex w-full max-w-4xl h-[80vh] bg-white rounded-xl shadow overflow-hidden">
    <aside class="w-48 p-4 bg-gray-100 space-y-2">
      <div id="status" x-text="status" class="text-xs font-semibold text-gray-500"></div>
      <div id="debug-status" x-text="debugStatus" class="text-xs text-gray-400"></div>
      <div id="error" x-show="error" x-text="error" class="text-xs text-red-600"></div>
      <div id="face" x-text="emotion" class="text-4xl"></div>
      <audio controls x-ref="player" class="w-full"></audio>
      <!-- autoplay on the video element can race with manual play() calls -->
      <video x-ref="video" playsinline class="w-full max-h-40"></video>
      <ul id="thoughts" class="p-2 bg-gray-50 rounded flex flex-col space-y-1 text-xs text-gray-500 list-none max-h-24 overflow-y-auto">
        <template x-for="(t, i) in thoughts" :key="'t'+i">
          <li x-text="t"></li>
        </template>
      </ul>
    </aside>
    <main class="flex flex-col flex-1 p-6 space-y-4">
      <ul id="log" x-ref="log" class="chat-log p-2 bg-gray-50 rounded flex flex-col space-y-1 flex-grow list-none">
        <template x-for="(msg, i) in log" :key="i">
          <li :class="msg.role" x-text="msg.text"></li>
        </template>
      </ul>
      <form class="flex gap-2 mt-auto" @submit.prevent="send">
        <label for="input" class="sr-only">Message</label>
        <input type="text" autofocus class="flex-grow border rounded px-3 py-2" placeholder="Say something..." x-model="input" />
        <button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">Send</button>
        <button type="button" @click.prevent="capture" class="px-3 py-2 bg-gray-300 rounded">Snap</button>
      </form>
    </main>
  </div>
  <script>
    function chatApp() {
      return {
        ws: null,
        debugWs: null,
        status: 'WS: connecting',
        debugStatus: 'Debug: connecting',
        log: [],
        thoughts: [],
        input: '',
        emotion: '😐',
        error: '',
        audioQueue: [],
        playing: false,
        stream: null,
        captureInterval: null,
        init() { this.connect(); this.connectDebug(); this.initCamera(); },
        initCamera() {
          if (this.stream) {
            this.stream.getTracks().forEach(t => t.stop());
          }
          if (this.captureInterval) {
            clearInterval(this.captureInterval);
            this.captureInterval = null;
          }
          navigator.mediaDevices.getUserMedia({ video: true }).then(s => {
            this.stream = s;
            this.stream.oninactive = () => this.initCamera();
            const v = this.$refs.video;
            v.srcObject = s;
            v.play().catch(err => {
              console.error('video play failed:', err);
              this.error = 'Video play failed: ' + err.message;
            });
            v.onerror = () => this.initCamera();
            this.startCaptureLoop();
          }).catch(err => {
            console.error('getUserMedia failed:', err);
            this.error = 'Camera error: ' + err.message;
          });
        },
        connect() {
          if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
            return;
          }
          if (this.ws) { this.ws.close(); }
          this.status = 'WS: connecting';
          this.ws = new WebSocket('ws://localhost:3000/ws');
          this.ws.onopen = () => this.status = 'WS: open';
          this.ws.onclose = () => { this.status = 'WS: closed'; setTimeout(() => this.connect(), 1000); };
          this.ws.onerror = (e) => {
            console.error('WebSocket error:', e);
            this.status = 'WS: error';
            this.error = 'WebSocket error';
          };
          this.ws.onmessage = (ev) => {
            try {
              const data = JSON.parse(ev.data);
              if (data.kind === 'pete-emotion') {
                this.emotion = data.text;
              } else if (data.kind === 'pete-speech') {
                this.audioQueue.push({ audio: data.audio, text: data.text });
                this.playNext();
              }
            } catch (err) {
              console.error('WS message error:', err);
              this.error = 'WS parse error: ' + err.message;
              this.append('system', ev.data);
            }
          };
        },
        connectDebug() {
          if (this.debugWs && (this.debugWs.readyState === WebSocket.OPEN || this.debugWs.readyState === WebSocket.CONNECTING)) {
            return;
          }
          if (this.debugWs) { this.debugWs.close(); }
          this.debugStatus = 'Debug: connecting';
          this.debugWs = new WebSocket('ws://localhost:3000/debug');
          this.debugWs.onopen = () => this.debugStatus = 'Debug: open';
          this.debugWs.onclose = () => { this.debugStatus = 'Debug: closed'; setTimeout(() => this.connectDebug(), 1000); };
          this.debugWs.onerror = (e) => {
            console.error('Debug WebSocket error:', e);
            this.debugStatus = 'Debug: error';
            this.error = 'Debug WebSocket error';
          };
          this.debugWs.onmessage = (ev) => {
            try {
              const d = JSON.parse(ev.data);
              if (d.type === 'wit') {
                this.thoughts.push(`${d.name}: ${d.prompt} => ${d.output}`);
              }
            } catch (err) {
              console.error('Debug message error:', err);
              this.error = 'Debug parse error: ' + err.message;
            }
          };
        },
        playNext() {
          if (this.playing || this.audioQueue.length === 0) return;
          const { audio, text } = this.audioQueue.shift();
          const player = this.$refs.player;
          this.append('system', text);
          let mime = 'audio/wav';
          const tryPlay = () => {
            player.src = `data:${mime};base64,${audio}`;
            const attempt = player.play();
            if (attempt !== undefined) {
              attempt.catch(err => {
                if (err.name === 'NotSupportedError' && mime === 'audio/wav') {
                  mime = 'audio/mpeg';
                  tryPlay();
                } else if (err.name === 'NotAllowedError') {
                  const resume = () => {
                    document.removeEventListener('click', resume);
                    tryPlay();
                  };
                  document.addEventListener('click', resume);
                } else {
                  console.error('Audio playback failed:', err);
                  this.playing = false;
                  this.ws.send(JSON.stringify({ type: 'played', text }));
                  this.playNext();
                }
              });
            }
          };
          player.onerror = () => {
            this.playing = false;
            this.ws.send(JSON.stringify({ type: 'played', text }));
            console.error('Audio element error');
            this.playNext();
          };
          player.onended = () => {
            this.playing = false;
            this.ws.send(JSON.stringify({ type: 'played', text }));
            console.log('sent played ack:', text);
            this.playNext();
          };
          this.playing = true;
          tryPlay();
        },
        append(role, text) {
          const el = this.$refs.log;
          const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 2;
          if (this.log.length && this.log[this.log.length - 1].role === role) {
            this.log[this.log.length - 1].text += text;
          } else {
            this.log.push({ role, text });
          }
          this.$nextTick(() => {
            if (atBottom) el.scrollTop = el.scrollHeight;
          });
        },
        send() {
          if (!this.input) return;
          this.append('user', this.input);
          this.ws.send(JSON.stringify({ type: 'user', message: this.input }));
          this.input = '';
        },
        startCaptureLoop() {
          if (this.captureInterval) return;
          this.captureInterval = setInterval(() => this.capture(), 2000);
        },
        capture() {
          const v = this.$refs.video;
          const c = document.createElement('canvas');
          c.width = v.videoWidth;
          c.height = v.videoHeight;
          c.getContext('2d').drawImage(v, 0, 0);
          const base64 = c.toDataURL('image/png').split(',')[1];
          this.ws.send(JSON.stringify({ type: 'image', mime: 'image/png', base64 }));
        }
      }
    }
  </script>
</body>
</html>
